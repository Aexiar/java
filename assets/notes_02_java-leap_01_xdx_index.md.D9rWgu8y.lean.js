import{_ as i,o as l,c as a,a6 as e}from"./chunks/framework.SZKFHIgh.js";const t="/java/assets/1.uqu1DEK4.png",n="/java/assets/2.DcyDw4rB.jpg",o="/java/assets/3.CCba8gww.png",c="/java/assets/4.CBeLZqxb.jpg",d="/java/assets/5.Ck3AfyPP.png",p="/java/assets/6.BN-EiKRH.svg",r="/java/assets/7.B3V_haCA.svg",h="/java/assets/8.ZyT8MEMR.svg",u="/java/assets/9.QdyrLkbx.jpeg",k="/java/assets/10.wg7a3XFP.gif",g="/java/assets/11.M8jrrq2u.gif",b="/java/assets/12.BdWdvezm.png",m="/java/assets/13.C_QI84u9.svg",y="/java/assets/14.BB6sjxx5.svg",E="/java/assets/15.CHyA9Yy8.svg",v="/java/assets/16.DqDR6Thp.svg",_="/java/assets/17.3t5rXZRH.gif",C="/java/assets/18.BRUArxJK.jpg",F="/java/assets/19.DIXK93xX.jpg",P="/java/assets/20.Bvu6CpUv.gif",x="/java/assets/21.DHPPX3_T.gif",B="/java/assets/22.0fJSxyVO.png",q="/java/assets/23.BMbidj_P.svg",U="/java/assets/7.B3V_haCA.svg",f="/java/assets/25.ByH0yblI.svg",j="/java/assets/26.mM_KqmHv.svg",D="/java/assets/27.BfL0oaIY.svg",A="/java/assets/28.CNllxnWj.svg",z="/java/assets/29.DFdiAx6C.svg",L="/java/assets/30.BE-V3AAI.png",M="/java/assets/31.BhFeJOJc.svg",I="/java/assets/32.CsjCs-bs.svg",O="/java/assets/33.D4epU-ry.svg",w="/java/assets/34.B9ulm0Bd.png",T="/java/assets/35.DjcMLTiM.png",R="/java/assets/35.DjcMLTiM.png",W="/java/assets/33.D4epU-ry.svg",H="/java/assets/38.DVsPBUJ9.svg",J="/java/assets/39.CMeoEROy.svg",Z=JSON.parse('{"title":"第一章：程序到底是怎么在计算机中运行的？","description":"","frontmatter":{},"headers":[],"relativePath":"notes/02_java-leap/01_xdx/index.md","filePath":"notes/02_java-leap/01_xdx/index.md","lastUpdated":1732264309000}'),K={name:"notes/02_java-leap/01_xdx/index.md"};function S(G,s,Q,V,X,N){return l(),a("div",null,s[0]||(s[0]=[e('<h1 id="第一章-程序到底是怎么在计算机中运行的" tabindex="-1">第一章：程序到底是怎么在计算机中运行的？ <a class="header-anchor" href="#第一章-程序到底是怎么在计算机中运行的" aria-label="Permalink to &quot;第一章：程序到底是怎么在计算机中运行的？&quot;">​</a></h1><h2 id="_1-1-回顾冯·诺依曼体系结构" tabindex="-1">1.1 回顾冯·诺依曼体系结构 <a class="header-anchor" href="#_1-1-回顾冯·诺依曼体系结构" aria-label="Permalink to &quot;1.1 回顾冯·诺依曼体系结构&quot;">​</a></h2><ul><li><p><code>冯·诺依曼</code>体系结构的理论要点如下：</p><ul><li>① <strong>存储程序</strong>：<code>程序指令</code>和<code>数据</code>都存储在计算机的内存中，这使得程序可以在运行时修改。</li><li>② <strong>二进制逻辑</strong>：所有<code>数据</code>和<code>指令</code>都以<code>二进制</code>形式表示。</li><li>③ <strong>顺序执行</strong>：指令按照它们在内存中的顺序执行，但可以有条件地改变执行顺序。</li><li>④ <strong>五大部件</strong>：计算机由<code>运算器</code>、<code>控制器</code>、<code>存储器</code>、<code>输入设备</code>和<code>输出设备</code>组成。</li><li>⑤ <strong>指令结构</strong>：指令由操作码和地址码组成，操作码指示要执行的操作，地址码指示操作数的位置。</li><li>⑥ <strong>中心化控制</strong>：计算机的控制单元（CPU）负责解释和执行指令，控制数据流。</li></ul></li><li><p><code>冯·诺依曼</code>体系结构中的五大部件，如下所示：</p></li></ul><p><img src="'+t+'" alt="img" loading="lazy"></p><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><p>上述的组件协同工作，构成了一个完整的计算机系统：</p><ul><li><code>运算器</code>和<code>控制器</code>通常被集成在一起，组成中央处理器（CPU），负责数据处理和指令执行。</li><li><code>存储器</code>（内存）保存数据和程序，是计算机运作的基础。</li><li><code>输入设备</code>和<code>输出设备</code>负责与外界的交互，确保用户能够输入信息并接收计算机的处理结果。</li></ul></div><h2 id="_1-2-现代计算机和冯·诺依曼体系结构的关系" tabindex="-1">1.2 现代计算机和<code>冯·诺依曼</code>体系结构的关系 <a class="header-anchor" href="#_1-2-现代计算机和冯·诺依曼体系结构的关系" aria-label="Permalink to &quot;1.2 现代计算机和`冯·诺依曼`体系结构的关系&quot;">​</a></h2><ul><li>现代微型个人计算机中主板的结构，如下所示：</li></ul><p><img src="'+n+'" alt="" loading="lazy"></p><ul><li>其中，<code>控制器</code>在冯·诺依曼体系结构中主要负责指令的解释和控制，它对应于 CPU 内部的<code>控制单元（Control Unit，CU）</code>，其主要功能有： <ul><li>① <code>指令的取指、解码和控制</code>：将指令发送给CPU的各个单元执行。</li><li>② <code>发出控制信号</code>：协调各部件（如存储器和I/O设备）之间的数据交换和操作。</li></ul></li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><p><code>控制器</code>，即：<code>控制单元</code>，是 CPU 的核心管理者，使得指令得以被顺序执行，并管理程序流程。</p></div><ul><li>其中，<code>运算器</code>在冯·诺依曼体系结构中主要用于执行各种算术运算和逻辑运算，它对应于 CPU 内部的<code>算术逻辑单元（Arithmetic Logic Unit，ALU）</code>，其主要功能有： <ul><li>① <code>处理算术运算</code>：加、减、乘、除等算术操作。</li><li>② <code>处理逻辑运算</code>：与、或、非等逻辑操作。</li></ul></li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><p><code>运算器</code>，即：<code>算术逻辑单元</code>，使得 CPU 可以直接处理数据运算，是计算机执行计算任务的核心。</p></div><ul><li>其中，<code>存储器</code>在冯·诺依曼体系结构中主要用于存放程序指令和数据，对应于计算机的<code>主存储器（RAM）</code>，也包括 CPU 内部的 <code>寄存器（Register）</code>和<code>缓存（Cache）</code>，其主要功能有： <ul><li>① <code>寄存器</code>：寄存器是 CPU 内部的高速存储单元，主要用于临时存储数据和指令。</li><li>② <code>缓存</code>：缓存是 CPU 中的高速缓存存储器，存放的是最近使用的数据或指令，分为 L1、L2、L3 三级缓存。缓存的作用是减少CPU访问内存的时间，因为缓存比内存的访问速度要快得多。</li><li>③ <code>主存储器</code>：用于长期存储数据和程序指令，CPU 通过<code>总线接口单元</code>与它交互。</li></ul></li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><p><code>存储器</code>在冯·诺依曼结构中的位置十分重要，因为程序指令和数据都存储在这里，CPU 直接从这里获取需要的指令和数据。</p></div><ul><li>其中，<code>输入设备</code>提供外界与计算机交互的方式，如：键盘、鼠标等，用户通过这些设备向计算机输入数据或指令。在现代计算机中，输入设备通过 I/O 接口连接到计算机系统，CPU 通过总线控制与它们通信。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><ul><li>① 虽然输入设备不直接存在于 CPU 内部，但它们在计算机系统整体架构中属于不可缺少的部件。</li><li>② 控制器发出的信号可以协调 CPU 从输入设备接收数据。</li></ul></div><ul><li>其中，<code>输出设备</code>是冯·诺依曼结构中实现计算结果输出的部分，如：显示器、打印机等。CPU 处理完数据后，最终需要通过输出设备来将结果展示给用户。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><p>和输入设备一样，输出设备也通过 I/O 接口连接到计算机系统，控制器和总线接口单元负责协调 CPU 与输出设备的交互。</p></div><h2 id="_1-3-现代-cpu-的结构" tabindex="-1">1.3 现代 CPU 的结构 <a class="header-anchor" href="#_1-3-现代-cpu-的结构" aria-label="Permalink to &quot;1.3 现代 CPU 的结构&quot;">​</a></h2><ul><li>现代 CPU 在主板上的示意图，如下所示：</li></ul><p><img src="'+o+'" alt="" loading="lazy"></p><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><p>现代 CPU 除了控制单元、算术逻辑单元、寄存器、缓存等，还有浮点运算单元、总线接口单元、分支预测单元、指令流水线以及超标量单元和多核单元：</p><ul><li>① <code>浮点运算单元</code>（Floating Point Unit，FPU）：专门用于处理浮点数运算。浮点运算通常比整数运算复杂且计算量大，因此 FPU 可以加速此类操作，尤其是在科学计算、图形处理等需要大量小数计算的应用中。</li><li>② <code>总线接口单元</code>（Bus Interface Unit，BIU）：负责与系统总线，如：数据总线和地址总线进行交互，将数据在CPU和主存储器之间传递。它管理从内存加载指令和数据到CPU，以及将计算结果写回到内存。</li><li>③ <code>分支预测单元</code>（Branch Predictor Unit）：分支预测单元用于预测程序中的分支，如：if-else、循环跳转等，将会如何执行。正确的预测可以避免不必要的指令等待，提高执行效率。</li><li>④ <code>指令流水线</code>（Instruction Pipeline）：指令流水线允许多个指令同时进行不同阶段的处理（如：取指令、解码、执行等），从而提升 CPU 的并行处理能力，使得 CPU 在同一时刻能高效地处理多条指令。</li><li>⑤ <code>超标量单元</code>和<code>多核结构</code>：每个核都有独立的 ALU 和 CU，可以并行处理不同任务，实现<code>多线程</code>和<code>并行计算</code>。</li></ul></div><h2 id="_1-4-程序到底是怎么在计算机中运行的" tabindex="-1">1.4 程序到底是怎么在计算机中运行的？ <a class="header-anchor" href="#_1-4-程序到底是怎么在计算机中运行的" aria-label="Permalink to &quot;1.4 程序到底是怎么在计算机中运行的？&quot;">​</a></h2><h3 id="_1-4-1-概述" tabindex="-1">1.4.1 概述 <a class="header-anchor" href="#_1-4-1-概述" aria-label="Permalink to &quot;1.4.1 概述&quot;">​</a></h3><ul><li>程序在计算机中运行的过程涉及多个复杂的步骤，从代码到实际的机器执行分为几个主要阶段：编写代码、编译或解释代码、加载程序、CPU 执行指令和与硬件交互。</li><li>程序在计算机中运行的主要流程，如下所示：</li></ul><p><img src="'+c+`" alt="" loading="lazy"></p><h3 id="_1-4-2-编写代码" tabindex="-1">1.4.2 编写代码 <a class="header-anchor" href="#_1-4-2-编写代码" aria-label="Permalink to &quot;1.4.2 编写代码&quot;">​</a></h3><ul><li>程序员用高级编程语言，如：Python、Java、C、C++等，编写程序代码。这些高级语言对人类更友好，但计算机无法直接理解这些代码。</li></ul><h3 id="_1-4-3-编译或解释" tabindex="-1">1.4.3 编译或解释 <a class="header-anchor" href="#_1-4-3-编译或解释" aria-label="Permalink to &quot;1.4.3 编译或解释&quot;">​</a></h3><ul><li>代码编写完成后，需要经过编译或解释的步骤： <ul><li><code>编译</code>（Compile）：将高级语言代码转换为机器码。机器码是计算机能够直接执行的二进制代码。像 C、C++ 这样的编译型语言需要通过编译器将代码编译成可执行文件。</li><li><code>解释</code>（Interpret）：解释型语言，如：Python等，不需要编译为机器码，而是由解释器逐行读取和执行代码。在这种情况下，解释器本身负责将代码翻译为机器能够执行的指令。</li></ul></li></ul><h3 id="_1-4-4-加载程序" tabindex="-1">1.4.4 加载程序 <a class="header-anchor" href="#_1-4-4-加载程序" aria-label="Permalink to &quot;1.4.4 加载程序&quot;">​</a></h3><ul><li>一旦代码被编译或准备好，操作系统（Windows、Linux、macOS） 会将程序加载到内存中。</li><li>操作系统中的<code>加载器</code>（Loader）负责将程序的机器代码加载到内存中，并为程序分配资源，如：内存空间、文件句柄等。</li></ul><h3 id="_1-4-5-cpu-执行指令" tabindex="-1">1.4.5 CPU 执行指令 <a class="header-anchor" href="#_1-4-5-cpu-执行指令" aria-label="Permalink to &quot;1.4.5 CPU 执行指令&quot;">​</a></h3><ul><li>程序加载到内存后，CPU便开始执行指令。整个过程如下： <ul><li><code>取指令</code>（Fetch）：CPU 的控制单元从内存中获取下一条指令。</li><li><code>解码指令</code>（Decode）：控制单元将指令译码成具体的操作。不同指令会涉及不同的操作类型，如：算术运算、逻辑运算、数据移动等。</li><li><code>执行指令</code>（Execute）：CPU 执行指令，完成指定的操作。操作可能包括计算、存取内存、跳转到其他指令等。</li><li><code>写回</code>（Writeback）：执行完的结果可能被写回到寄存器或内存中，供后续指令使用。</li></ul></li></ul><h3 id="_1-4-6-与硬件交互" tabindex="-1">1.4.6 与硬件交互 <a class="header-anchor" href="#_1-4-6-与硬件交互" aria-label="Permalink to &quot;1.4.6 与硬件交互&quot;">​</a></h3><ul><li>计算机程序的执行不仅仅是 CPU 处理指令，还涉及到不同硬件的协作，如：内存、硬盘、输入输出设备等。</li><li>通过操作系统的管理，程序可以访问并控制这些硬件，例如： <ul><li><code>内存管理</code>：操作系统分配内存给程序，CPU 在运行时不断从内存中取出指令和数据。</li><li><code>硬盘存储</code>：程序可能需要从硬盘读取或写入数据。</li><li><code>I/O操作</code>：程序需要与外部设备交互，如：显示输出、接收键盘输入等。</li></ul></li></ul><h1 id="第二章-虚拟地址空间" tabindex="-1">第二章：虚拟地址空间 <a class="header-anchor" href="#第二章-虚拟地址空间" aria-label="Permalink to &quot;第二章：虚拟地址空间&quot;">​</a></h1><h2 id="_2-1-概述" tabindex="-1">2.1 概述 <a class="header-anchor" href="#_2-1-概述" aria-label="Permalink to &quot;2.1 概述&quot;">​</a></h2><ul><li>如果你学习 C 语言，那么就可以通过 <code>&amp;</code> 运算符来获取变量的内存地址，如下所示：</li></ul><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 全局变量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 禁用 stdout 缓冲区</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setbuf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stdout, nullptr);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;a = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%p\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // a = 0x55fda7351010</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;b = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%p\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // b = 0x55fda7351014</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ul><li>我们也知道，现代操作系统是<code>多用户</code>、<code>多任务</code>、<code>图形化</code>、<code>网络化</code>的操作系统。其中，所谓的<code>多任务</code>就是可以支持多个应用程序（进程），如下所示：</li></ul><p><img src="`+d+'" alt="" loading="lazy"></p><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><ul><li>① 正如上面的程序一样，程序在链接的时候，内存地址就已经确定了，无法改变。</li><li>② 如果此时，物理内存中的内存地址已经被该程序占用了，那么其它程序岂不是运行不了？</li><li>③ 如果此时，物理内存中的内存地址已经被其它程序占用了，那么该程序岂不是运行不了？</li></ul></div><ul><li>其实，这些地址都是假的，并不是真实的物理地址，而是虚拟地址（虚地址）。虚拟地址（虚地址）需要通过 CPU 内部的 MMU（Memory Management Unit，内存管理单元）来将这些虚拟地址（虚地址）转换为物理地址（实地址），如下所示：</li></ul><p><img src="'+p+'" alt="" loading="lazy"></p><h2 id="_2-2-虚拟地址空间模型" tabindex="-1">2.2 虚拟地址空间模型 <a class="header-anchor" href="#_2-2-虚拟地址空间模型" aria-label="Permalink to &quot;2.2 虚拟地址空间模型&quot;">​</a></h2><ul><li>为了更好的管理程序，操作系统将虚拟地址空间分为了不同的内存区域，这些内存区域存放的数据、用途、特点等皆有不同，下面是 Linux 下 32 位环境的经典内存模型，如下所示：</li></ul><p><img src="'+r+'" alt="" loading="lazy"></p><ul><li>每个内存区域的特点，如下所示：</li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">内存分区</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">程序代码区（code）</td><td style="text-align:left;">存储程序的执行代码，通常为只读区，包含程序的指令。 程序启动时，这部分内存被加载到内存中，并不会在程序执行期间改变。</td></tr><tr><td style="text-align:left;">常量区（constant）</td><td style="text-align:left;">存放程序中定义的常量值，通常也是只读的，这些常量在程序运行期间不可修改。</td></tr><tr><td style="text-align:left;">全局数据区（global data）</td><td style="text-align:left;">存储程序中定义的全局变量和静态变量。 这些变量在程序的整个生命周期内存在，且可以被修改。</td></tr><tr><td style="text-align:left;">堆区（heap）</td><td style="text-align:left;">用于动态分配内存，例如：通过 <code>malloc</code> 或 <code>new</code> 分配的内存块。 堆区的内存由程序员手动管理，负责分配和释放。 如果程序员不释放，程序运行结束时由操作系统回收。</td></tr><tr><td style="text-align:left;">动态链接库</td><td style="text-align:left;">动态链接库（如： <code>.dll</code> 或 <code>.so</code> 文件）被加载到内存中特定的区域，供程序运行时使用。</td></tr><tr><td style="text-align:left;">栈区（stack）</td><td style="text-align:left;">用于存储函数调用的局部变量、函数参数和返回地址。 栈是自动管理的，随着函数的调用和返回，栈上的内存会自动分配和释放。</td></tr></tbody></table><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><ul><li>① 程序代码区、常量区、全局数据区在程序加载到内存后就分配好了，并且在程序运行期间一直存在，不能销毁也不能增加（大小已被固定），只能等到程序运行结束后由操作系统收回，所以全局变量、字符串常量等在程序的任何地方都能访问，因为它们的内存一直都在。</li><li>② 函数被调用时，会将参数、局部变量、返回地址等与函数相关的信息压入栈中，函数执行结束后，这些信息都将被销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部，因为它们的内存不在了。</li><li>③ 常量区、全局数据区、栈上的内存由系统自动分配和释放，不能由程序员控制。程序员唯一能控制的内存区域就是堆（Heap）：它是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分，在这片空间中，程序可以申请一块内存，并自由地使用（放入任何数据）。堆内存在程序主动释放之前会一直存在，不随函数的结束而失效。在函数内部产生的数据只要放到堆中，就可以在函数外部使用。</li></ul></div><ul><li>在 64 位 Linux 环境下，虚拟地址空间大小为 256TB，Linux 将高 128TB 的空间分配给内核使用，而将低 128TB 的空间分配给用户程序使用，如下所示：</li></ul><p><img src="'+h+'" alt="" loading="lazy"></p><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><ul><li>① <code>程序代码区</code>，也可以称为<code>代码段</code>；而<code>全局数据区</code>和<code>常量区</code>，也可以称为<code>数据段</code>。</li><li>② <code>全局数据区</code>分为<code>初始化数据段</code>（存储已初始化的全局变量和静态变量）和<code>未初始化数据段</code>（存储未初始化的全局变量和静态变量）；<code>常量区</code>也称为<code>只读数据段</code>，通常是只读的，防止数据被修改。</li><li>③ 冯·诺依曼体系结构中的<code>程序</code>，也被称为<code>存储式程序</code>，需要通过加载器（Loader），将程序从硬盘加载到内存中运行。</li><li>④ <code>存储式程序</code>中的<code>程序</code>分为<code>指令</code>和<code>数据</code>；其中，<code>代码段</code>中保存的是<code>指令</code>，<code>数据段</code>中保存的是<code>数据</code>。</li></ul></div><h1 id="第三章-虚拟内存地址" tabindex="-1">第三章：虚拟内存地址 <a class="header-anchor" href="#第三章-虚拟内存地址" aria-label="Permalink to &quot;第三章：虚拟内存地址&quot;">​</a></h1><h2 id="_3-1-内存和内存地址" tabindex="-1">3.1 内存和内存地址 <a class="header-anchor" href="#_3-1-内存和内存地址" aria-label="Permalink to &quot;3.1 内存和内存地址&quot;">​</a></h2><h3 id="_3-1-1-内存" tabindex="-1">3.1.1 内存 <a class="header-anchor" href="#_3-1-1-内存" aria-label="Permalink to &quot;3.1.1 内存&quot;">​</a></h3><ul><li><p><code>内存</code>是一种<code>计算机硬件</code>，是<code>软件</code>在<code>运行过程</code>中，用来<code>临时存储数据</code>的。在生活中，最为常见的<code>内存</code>就是<code>随机存取存储器（RAM，内存条</code>），其特点如下所示：</p><ul><li>① 生活中最常见的内存类型，用于存储当前运行的程序和数据。</li><li>② 内存是易失性存储器，这意味着断电后数据会丢失。</li><li>③ 它具有高速读写特性，适用于需要快速访问的操作。</li></ul></li><li><p>内存条的外观，如下所示：</p></li></ul><p><img src="'+u+'" alt="" loading="lazy"></p><ul><li>像我们平常使用<code>记事本</code>软件一样，当我们输入一些文字的时候，其实是将数据<code>临时</code>保存在内存中的，如下所示：</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><ul><li>① 目前，很多软件都很智能，如果用户没有将数据到保存文件中，将显示红色，以警告用户还没有保存数据，提醒用户需要尽快保存数据！！！</li><li>② 但是，也有很多软件提供了自动保存数据的功能，其原理就是定时（1s、3s、5s）将内存中的数据刷新到文件中，以防止数据丢失！！！</li><li>③ 将数据从内存存储到文件中，专业的说法是落盘（落在磁盘上）。</li></ul></div><p><img src="'+k+'" alt="" loading="lazy"></p><ul><li>此时，如果我们在没有保存的过程下，将<code>记事本</code>软件关闭，那么刚才输入的文字将丢失；下次，再打开同样的文件（将数据从磁盘加载进内存，再交给 CPU），之前输入的文字将不复存在，如下所示：</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><ul><li>① 目前，很多软件都很智能，如果你没有保存，将提醒你是否保存或丢失刚才输入的文字。</li><li>② 但是，也有很多软件提供了自动保存数据的功能，其原理就是定时（1s、3s、5s）将内存中的数据刷新到文件中，以防止数据丢失！！！</li><li>③ 将数据从内存存储到文件中，专业的说法是落盘（落在磁盘上）。</li></ul></div><p><img src="'+g+'" alt="" loading="lazy"></p><div class="important custom-block github-alert"><p class="custom-block-title">重要</p><p></p><p>内存就是软件在运行过程中，用来临时存储数据的，最为重要的两个步骤就是：</p><ul><li>① 将数据<code>保存</code>到内存中。</li><li>② 从内存中的<code>对应位置</code>将数据<code>取出来</code>。</li></ul></div><h3 id="_3-1-2-内存地址" tabindex="-1">3.1.2 内存地址 <a class="header-anchor" href="#_3-1-2-内存地址" aria-label="Permalink to &quot;3.1.2 内存地址&quot;">​</a></h3><ul><li>在这个计算机的内存条，动不动就 <code>32GB</code>、<code>64GB</code> 、<code>128GB</code> 或更高的年代，如下所示：</li></ul><p><img src="'+b+'" alt="" loading="lazy"></p><ul><li>如果有一个 int （4 个字节）类型的数据 <code>2</code> ，如何将这个数据保存到内存中？（对应上述的步骤 ①）</li></ul><p><img src="'+m+'" alt="" loading="lazy"></p><ul><li>就算数据 <code>2</code> 已经保存到内存中，那么内存中那么多的数据，我们又该如何取出呢？（对应上述的步骤 ②）</li></ul><p><img src="'+y+'" alt="" loading="lazy"></p><div class="important custom-block github-alert"><p class="custom-block-title">重要</p><p></p><p>答案就是<code>内存地址</code>。</p></div><ul><li>操作系统为了更快的去管理内存中的数据，会将<code>内存条</code>按照<code>字节</code>划分为一个个的<code>单元格</code>，如下所示：</li></ul><p><img src="'+E+'" alt="" loading="lazy"></p><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><p>计算机中存储单位的换算，如下所示：</p><ul><li>1 B = 8 bit。</li><li>1 KB = 1024 B。</li><li>1 MB = 1024 KB。</li><li>1 GB = 1024 MB。</li><li>1 TB = 1024 GB 。</li><li>……</li></ul></div><ul><li>为了方便管理，每个独立的小单元格，都有自己唯一的编号（内存地址），如下所示：</li></ul><p><img src="'+v+'" alt="" loading="lazy"></p><ul><li><p>之所以，加了<code>内存地址</code>，就能<code>加快</code>数据的存取速度，可以类比生活中的<code>字典</code>：</p><ul><li>如果没有使用<code>拼音查找法</code>或<code>部首查找法</code>，我们需要一页一页，一行一行的，在整个字典中去搜索我们想要了解的汉字，效率非常低（如果要搜索的汉字在最后一页，可能需要将整个字典从头到尾翻一遍，这辈子真有可能翻得完？）。</li></ul><p><img src="'+_+'" alt="" loading="lazy"></p><ul><li>如果使用<code>拼音查找法</code>或<code>部首查找法</code>，我们可以很快的定位到所要了解汉字所在的页数，加快了搜索的效率。</li></ul><p><img src="'+C+'" alt="" loading="lazy"></p><p><img src="'+F+'" alt="" loading="lazy"></p></li><li><p>同样的道理，如果<code>没有</code>内存地址，我们只能一个个的去寻找想要的数据，效率非常低下，如下所示：</p></li></ul><p><img src="'+P+'" alt="" loading="lazy"></p><ul><li>如果<code>使用</code>内存地址，我们就可以直接定位到指定的数据，效率非常高，如下所示：</li></ul><p><img src="'+x+`" alt="" loading="lazy"></p><div class="important custom-block github-alert"><p class="custom-block-title">重要</p><p></p><p>内存地址就是虚拟内存空间中某个内存单元（某一个字节区域）的唯一标识。</p><ul><li>① 内存地址是计算机中用于标识内存中某个特定位置的数值。</li><li>② 每个内存单元都有一个唯一的地址，这些地址可以用于访问和操作存储在内存中的数据。</li></ul></div><h3 id="_3-1-3-变量地址" tabindex="-1">3.1.3 变量地址 <a class="header-anchor" href="#_3-1-3-变量地址" aria-label="Permalink to &quot;3.1.3 变量地址&quot;">​</a></h3><ul><li>和内存地址相对应的还有一个非常重要的概念就是：变量地址。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><p>变量地址就是变量所占虚拟内存空间中的第一个字节的内存地址，即：首地址。</p></div><ul><li>以 <code>int</code> 类型的变量 <code>num</code> 为例，如下所示：</li></ul><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark has-highlighted vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 禁用 stdout 缓冲区</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setbuf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stdout, nullptr);</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;num = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%p\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">num);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ul><li>在 32 或 64 位操作系统中， <code>int</code> 类型的变量 <code>num</code> 的地址指的是：在内存中占用 4 个字节内存单元的首地址，如下所示：</li></ul><p><img src="`+B+'" alt="" loading="lazy"></p><h2 id="_3-2-虚拟内存地址" tabindex="-1">3.2 虚拟内存地址 <a class="header-anchor" href="#_3-2-虚拟内存地址" aria-label="Permalink to &quot;3.2 虚拟内存地址&quot;">​</a></h2><ul><li>计算机的总线层次结构是这样的，如下所示：</li></ul><p><img src="'+q+'" alt="" loading="lazy"></p><ul><li>对于 32 位操作系统中，CPU 的寄存器宽度是 32 位，因为它一次性处理的数据量是 32 位（4字节），那么内存地址范围就是<code>0000 0000 0000 0000 0000 0000 0000 0000</code> ~ <code>1111 1111 1111 1111 1111 1111 1111 1111</code> （2 ^ 32 次方）。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><ul><li>① 在实际开发中，如果使用二进制实现太长了，我们通常都是使用十六进制来表示的。</li><li>② 所以，32 位操作系统的虚拟内存地址范围是：<code>0x000000000</code>~ <code>0xFFFFFFFFF</code>。</li></ul></div><ul><li>对于 64 位操作系统中，CPU 的寄存器宽度是 64 位，因为它一次性处理的数据量是 64 位（8字节），那么内存地址范围就是<code>0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</code> ~ <code>1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111</code> （2 ^ 64 次方）。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><ul><li>① 在 64 位的操作系统中，一共有 18,446,744,073,709,551,616 个内存地址，其最大支持的内存大小是 18,446,744,073,709,551,616 字节，即 17,179 TB 。</li><li>② 虽然，从理论上 64 位的操作系统支持的内存最大容量是 17,179 TB；但是，实际操作系统会有所限制，如：win11 的 64 位支持的最大内存是 128 GB ~ 6 TB，Linux 64 位支持的最大内存通常是 256 TB。</li><li>③ 所以，64 位操作系统的虚拟内存地址范围是：<code>0x000000000000</code>~ <code>0x0000FFFFFFFFFFFF </code>。</li></ul></div><h2 id="_3-3-高地址和低地址" tabindex="-1">3.3 高地址和低地址 <a class="header-anchor" href="#_3-3-高地址和低地址" aria-label="Permalink to &quot;3.3 高地址和低地址&quot;">​</a></h2><ul><li>Linux 32 位的虚拟地址空间，如下所示：</li></ul><p><img src="'+U+`" alt="" loading="lazy"></p><ul><li>所谓的<code>低地址</code>：就是位于内存取值范围的较低端，即接近 0 的地址。</li><li>所谓的<code>高地址</code>：就是位于内存取值范围的较高端，即接近最大的地址。</li></ul><h2 id="_3-4-小端存储法" tabindex="-1">3.4 小端存储法 <a class="header-anchor" href="#_3-4-小端存储法" aria-label="Permalink to &quot;3.4 小端存储法&quot;">​</a></h2><ul><li>在 32 位操作系统中，对于整型变量 <code>num</code> ，如下所示：</li></ul><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark has-highlighted vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 禁用 stdout 缓冲区</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setbuf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stdout, nullptr);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;num = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%p\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">num); </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ul><li>我们知道，有符号数在计算机底层是采取的二进制补码的形式存储的，如下所示：</li></ul><p><img src="`+f+'" alt="" loading="lazy"></p><ul><li>如果要存储到虚拟内存空间中，是按照顺序从低到高进行存储？</li></ul><p><img src="'+j+'" alt="" loading="lazy"></p><ul><li>在 <code>x86_64</code> 等架构的 CPU 中，采取的是<code>小端存储法</code>，即：数据的<code>最低有效字节</code>存储在内存的<code>低地址处</code>，<code>高位字节</code>存储在高地址处，如下所示：</li></ul><p><img src="'+D+'" alt="" loading="lazy"></p><ul><li>那么，如果采用小端存储在内存中就是这样的，如下所示：</li></ul><p><img src="'+A+'" alt="" loading="lazy"></p><ul><li>需要注意的是，之前我们在画虚拟内存地址的时候，都是由低向高，方向是<code>↑</code>；但是，在很多编译器中，虽然虚拟内存地址还是由低向高，方向却是反的，即：<code>↓</code>，因为这样更容易调试，如下所示：</li></ul><p><img src="'+z+'" alt="" loading="lazy"></p><ul><li>在 CLion 中，也可以证明，如下所示：</li></ul><p><img src="'+L+'" alt="" loading="lazy"></p><h2 id="_3-5-大端存储法" tabindex="-1">3.5 大端存储法 <a class="header-anchor" href="#_3-5-大端存储法" aria-label="Permalink to &quot;3.5 大端存储法&quot;">​</a></h2><ul><li>所谓大端存储法，指的是在存储数据时，选择将此数据的<code>最低有效位字节存储</code>在<code>高内存地址</code>上。</li></ul><p><img src="'+M+'" alt="" loading="lazy"></p><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><p>大端存储法则比较符合直觉，直接将数据按照高有效位到低有效位，存储在低地址到高地址当中。</p></div><ul><li>大端存储法最常见的场景就是：网络传输数据时，使用大端序列来进行数据传输。</li></ul><h1 id="第四章-多线程" tabindex="-1">第四章：多线程 <a class="header-anchor" href="#第四章-多线程" aria-label="Permalink to &quot;第四章：多线程&quot;">​</a></h1><h2 id="_4-1-概述" tabindex="-1">4.1 概述 <a class="header-anchor" href="#_4-1-概述" aria-label="Permalink to &quot;4.1 概述&quot;">​</a></h2><ul><li>之前提高，在现代 CPU 的结构中，现代 CPU 中使用<code>超标量单元</code>和<code>多核结构</code>：每个核都有独立的 ALU 和 CU，可以并行处理不同任务，实现<code>多线程</code>和<code>并行计算</code>。</li><li>那么，到底什么是多线程？</li></ul><h2 id="_4-2-多核-cpu" tabindex="-1">4.2 多核 CPU <a class="header-anchor" href="#_4-2-多核-cpu" aria-label="Permalink to &quot;4.2 多核 CPU&quot;">​</a></h2><ul><li>在早期，CPU 只有一个核心，即：在任意时刻，单核 CPU 只能处理一个任务，如下所示：</li></ul><p><img src="'+I+'" alt="" loading="lazy"></p><ul><li>但是，随着技术的发展，CPU 开始朝着多核的方向发展，即：给 CPU 安装多个核心，每个核心都能独立的执行计算机指令；换言之，对于多核 CPU 而言，同一时刻可以处理多个任务，大幅度的提升程序的执行效率，如下所示：</li></ul><p><img src="'+O+'" alt="" loading="lazy"></p><ul><li>就目前而言，我们生活中常见的电子设备几乎都是多核的，如：台式机、笔记本电脑、手机、平板等。</li></ul><p><img src="'+w+`" alt="" loading="lazy"></p><ul><li>之前，我们编写的程序，都是单线程的程序，即：在任意时刻只能执行一条指令，整个运行过程中也就利用了 CPU 的一个核心，如下所示：</li></ul><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello World&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>如果要想发挥 CPU 多核的威力，我们还需要学习多线程编程技术，即：在任意时刻可以执行多个任务，充分利用 CPU 多核的优势，让程序的执行效率得到质的提升。</li></ul><h2 id="_4-3-什么是线程" tabindex="-1">4.3 什么是线程？ <a class="header-anchor" href="#_4-3-什么是线程" aria-label="Permalink to &quot;4.3 什么是线程？&quot;">​</a></h2><h3 id="_4-3-1-概述" tabindex="-1">4.3.1 概述 <a class="header-anchor" href="#_4-3-1-概述" aria-label="Permalink to &quot;4.3.1 概述&quot;">​</a></h3><ul><li>对于线程，很多教科书都是这么说的，如下所示：</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><ul><li>① 线程是操作系统能够进行运算调度的最小单位，它被包含在进程中，是进程的实际运作单位。</li><li>② 线程是进程中的⼀个执⾏单元，负责当前进程中程序的执⾏，⼀个进程中⾄少有⼀个线程。</li><li>③ 在计算机专用术语中，线程是指机器中连续的、顺序的属性集合。一个线程包含执行一系列机器指令所必须的机器状态，包括：当前指令位置、地址和数据寄存器等。</li></ul></div><ul><li>上面的说法完全正确，非常严谨；但是，总感觉“<code>好像说了什么，又好像没说什么？</code>”</li></ul><div class="important custom-block github-alert"><p class="custom-block-title">重要</p><p></p><p>其实，线程和进程的关系非常密切，要想搞清楚线程是什么，就必须搞清楚进程是什么？</p></div><h3 id="_4-3-2-进程-process" tabindex="-1">4.3.2 进程（process） <a class="header-anchor" href="#_4-3-2-进程-process" aria-label="Permalink to &quot;4.3.2 进程（process）&quot;">​</a></h3><ul><li>对于常见的操作系统，如：Windows、Linux 和 MacOS 而言，它们都属于<code>多用户</code>、<code>多任务</code>、<code>网络化</code>的操作系统。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><ul><li>① Linux 并不完全属于<code>图形化</code>的操作系统，Linux 完全可以在没有图形化界面的情况下执行任务。</li><li>② Windows 和 MacOS 完全属于<code>图形化</code>的操作系统。</li></ul></div><ul><li>在实际生活中，我们经常接触到的操作系统可能就是 Windows 了（<code>MacOS 系列实在是太贵了</code>），它可以同时支持运行 QQ、微信、Chrome 浏览器等多个应用程序，所以 Windows 当然是<code>多任务</code>的操作系统。</li><li>在多任务的操作系统中，对于同时执行的多个程序，操作系统负责给它们分配所需要的全部资源（，如：CPU、内存、I/O 设备等），还负责在恰当的时机（如：程序执行结束后）回收这些资源，以便后期其它的程序使用。</li><li>为了让操作系统高效的管理（分配和回收）这些计算机资源，人们就提出了<code>进程</code>的概念。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><p>通过<code>创建</code>进程和<code>销毁</code>进程，操作系统就实现了对计算机资源的高效管理。</p><ul><li><p>① 当一个程序执行的时候，操作系统负责分配所需要的全部资源，包括：程序代码、数据、CPU、内存以及 I/O 设备等，这些资源就会被组织成一个进程。换言之，在程序执行的时候，操作系统会创建进程并给它分配资源。</p><p><img src="`+T+'" alt="" loading="lazy"></p></li><li><p>② 当程序执行完毕后，操作系统就会销毁进程并回收资源。</p></li></ul></div><ul><li>虽然<code>进程</code>通常代表了一个正在执行的程序，但进程和程序之间并非总是严格的一一对应关系。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><p>进程可以理解为“正在执行的程序的实例”，但一个程序不一定只对应一个进程。</p><ul><li>① <code>程序</code>和<code>进程</code>的区别： <ul><li><code>程序</code>是存储在磁盘上的静态代码和数据，是一组指令的集合，本身不占用 CPU 时间、内存等资源。</li><li><code>进程</code>是程序运行后的动态表现，包含程序的指令、数据、以及用于运行程序的资源，如：CPU 时间、内存、文件句柄等。</li></ul></li><li>② <code>进程</code>和<code>程序</code>的关系： <ul><li>当一个<code>程序</code>被执行时，系统会为其创建一个<code>进程</code>，分配运行所需的资源，即：一个运行中的程序通常对应一个进程。</li><li>一个<code>程序</code>可以启动多个<code>进程</code>，如：用户可以多次启动同一个应用程序（打开多个文本编辑器窗口），每次启动都会创建一个新的进程。</li></ul></li><li>③ 进程并非总是单一执行： <ul><li>有些复杂应用（浏览器）会生成多个进程来分工，如：一个主进程负责管理，多个子进程负责不同的功能（渲染页面、处理插件等）。</li><li>在这种情况下，一个应用程序可能对应多个进程。</li></ul></li></ul></div><ul><li>对于系统中存在的多个进程，每个进程都拥有自己的内存空间和系统资源，它们之间相对独立，执行过程中不会互相干扰。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><ul><li>① 进程包含程序执行所需要的全部计算机资源，包括程序代码、数据、CPU、内存、I/O 设备等。</li><li>② 操作系统以进程为单位管理（分配和回收）计算机资源，也就是很多教材中讲的“进程是操作系统进行资源分配和调度的基本单位”。</li></ul></div><h3 id="_4-3-3-线程-thread" tabindex="-1">4.3.3 线程(thread) <a class="header-anchor" href="#_4-3-3-线程-thread" aria-label="Permalink to &quot;4.3.3 线程(thread)&quot;">​</a></h3><ul><li>我们知道，每个正在执行的应用程序都是一个进程，如下所示：</li></ul><p><img src="'+R+'" alt="" loading="lazy"></p><ul><li>一个完整的程序可能有多个子任务组成，有些任务是可以独立执行的（和其它的任务是同时执行的），每个独立执行的任务就是一个线程，如下所示：</li></ul><p><img src="'+W+'" alt="" loading="lazy"></p><ul><li>也就是说，线程是进程的一部分，进程和线程的关系，如下所示：</li></ul><p><img src="'+H+'" alt="" loading="lazy"></p><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><ul><li>① <code>一个进程可以包含多个线程</code>，这些<code>线程</code>可以<code>共享</code>进程的<code>内存空间</code>和一些<code>系统资源</code>，包括：<code>程序代码</code>、<code>数据</code>（<code>全局变量</code>、<code>静态变量</code>、<code>堆内存</code>）、打开的文件资源、网络连接等。当然，各个<code>线程</code>也有自己<code>私有</code>的资源，如：<code>程序计数器</code>、<code>寄存器</code>和<code>栈</code>等。</li><li>② <code>一个进程至少要包含 1 个线程</code>：进程只是操作系统为了方便管理计算机资源才创建的，真正负责执行程序的是线程，而不是进程。</li></ul></div><ul><li><p>当一个进程<code>只有</code>一个线程的时候，所有的程序代码全部由该线程负责执行，这样的程序叫做<code>单线程</code>程序。</p></li><li><p>当进程中<code>包含</code>多个线程时，每个线程分别负责执行一个任务，这样的程序叫做<code>多线程</code>程序。</p></li></ul><div class="caution custom-block github-alert"><p class="custom-block-title">注意</p><p></p><p><code>单线程程序</code>和<code>多线程程序</code>各有优缺点，如下所示：</p><ul><li>① 单线程程序编写简单、易于调试，但是只能顺序执行程序，适用于简单的应用场景。</li><li>② 多线程程序可以同时执行多个任务，执行效率高，但编写和调试过程比较复杂，容易出现数据竞争、死锁等问题，适用于复杂的应用场景。</li></ul></div><h3 id="_4-3-4-现实生活中的进程和线程的关系" tabindex="-1">4.3.4 现实生活中的进程和线程的关系 <a class="header-anchor" href="#_4-3-4-现实生活中的进程和线程的关系" aria-label="Permalink to &quot;4.3.4 现实生活中的进程和线程的关系&quot;">​</a></h3><ul><li>如果将<code>进程</code>看做是一个<code>工厂</code>的话，那么<code>线程</code>就是工厂中的一条条<code>生产线</code>，如下所示：</li></ul><p><img src="'+J+'" alt="" loading="lazy"></p><h3 id="_4-3-5-总结" tabindex="-1">4.3.5 总结 <a class="header-anchor" href="#_4-3-5-总结" aria-label="Permalink to &quot;4.3.5 总结&quot;">​</a></h3><ul><li>进程可以是使操作系统高效地管理计算机资源：当程序执行时，操作系统会创建一个进程，进程包含程序执行所需要的全部资源（CPU、内存、I/O 设备等）；当程序执行结束后，对应的进程会被操作系统销毁，占用的资源也会被操作系统回收。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><ul><li>① 线程是进程的一部分，一个进程可以包含多个线程，但至少要包含一个线程。</li><li>② 真正负责执行程序的，是线程，而不是进程。</li></ul></div><ul><li>目前，很多应用程序（软件）都是多线程程序，如：QQ 支持同时和多个好友聊天、迅雷可以同时下载多个资源、大部分杀毒软件可以同时开启杀毒、清理垃圾、电脑加速等功能。</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">提醒</p><p></p><p>在实际开发中，只会简单的<code>单线程编程</code>已经远远不足以满足实际项目需求，还需要学会<code>多线程编程</code>！！！</p></div>',168)]))}const Y=i(K,[["render",S]]);export{Z as __pageData,Y as default};
